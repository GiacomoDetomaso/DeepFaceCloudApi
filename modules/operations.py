from deepface.commons.distance import findThreshold, findEuclideanDistance
from numpy import argmin
from modules.blobs import ObjectPersistenceManager
from os import remove
from os.path import isfile

import pickle
import time

# If this constant is set, the input parameter is skipped. It is primarily used
# on the username and info input parameter in the FaceRepresentation class. That's 
# because if the action of 'find the closest representation' is performed, the
# FaceRepresentationManager just needs the embeddings of the input image to find
# the closest FaceRepresentation object.
SKIP = 'skip'

# A constant that defines the name of the blob that contains all the usernames
USERNAMES_BLOB = 'usernames.pkl'

# A constant that defines the name of the blob that contains all the representations
REPRESENTATIONS_BLOB = 'representations.pkl'

class FaceRepresentation:

    def __init__(self, username=SKIP, info=SKIP, embedding=SKIP) -> None:
        """
            - username: the identity of the representation
            - info:     additional information
            If no value is specified for username and info, then the instance will
            be considered as an unknown FaceRepresentation. By default, the embedding
            is setted to None, if not generated by generate_representation_single_face method
        """
        self.username = username
        self.info = info
        self.embedding = embedding


class FaceRepresentationDeleter:
    pass

class FaceRepresentationUploader:
    def __init__(self, persistence_manager: ObjectPersistenceManager, rep: FaceRepresentation) -> None:
        """
            - persistence_manager: the specific storage manager, used to upload the FaceRepresentation
            - rep: the representation to upload
        """
        self.persistence_manager = persistence_manager
        self.rep = rep

        if rep.username is SKIP or rep.info is SKIP or rep.embedding is SKIP:
            raise ValueError('Could not perform this action. Username and info are setted as SKIP, or embedding is '
                             'not evaluated')


    def upload_representation(self) -> bool:
        """
            This method is used to upload the FaceRepresentation
            to the Blob storage on Azure.
                - Return:   a boolean value
        """
        # Register the username if it is not duplicated
        is_username_free = self.__register_username(self.rep.username)

        if is_username_free:
            # Read the pkl representation file
            is_downloadable = self.persistence_manager.download(REPRESENTATIONS_BLOB)

            # If the data can be downloaded, open the file and extract 
            # the FaceRepresentations using pickle
            if is_downloadable:
                with open(REPRESENTATIONS_BLOB, 'rb') as f:
                    representations: list = pickle.loads(f.read())
            else:
                # Instantiate an empty list if the file is not created
                representations: list = list()

            # Append the new representation    
            representations.append(self.rep)

            # Update the pickle file
            with open(REPRESENTATIONS_BLOB, 'wb') as f:
                f.write(pickle.dumps(representations))

            self.persistence_manager.upload(REPRESENTATIONS_BLOB)

        self.__clean_temp_file()

        return is_username_free
    

    @staticmethod
    def __clean_temp_file():
        """
            Class method used to clean temporary files
        """
        if isfile(USERNAMES_BLOB):
            remove(USERNAMES_BLOB)

        if isfile(REPRESENTATIONS_BLOB):
            remove(REPRESENTATIONS_BLOB)


    def __register_username(self, username) -> bool:
        """
            - username: the username to check
            - Return: This method returns True if the username is
            already registered, False otherwise
        """
        is_downloaded = self.persistence_manager.download(USERNAMES_BLOB)
        usernames_set = set()

        if is_downloaded:
            with open(USERNAMES_BLOB, 'rb') as f:
                usernames_set: set = pickle.loads(f.read())

        flag = username not in usernames_set

        if flag:
            usernames_set.add(username)

            with open(USERNAMES_BLOB, 'wb') as f:
                f.write(pickle.dumps(usernames_set))

            self.persistence_manager.upload(USERNAMES_BLOB)

        return flag


class FaceRecognizer: 
    def __init__(self, persistence_manager: ObjectPersistenceManager, source_representations: list) -> None:
        """
            - persistence_manager: the specific storage manager, used to retrieve the stored representations
            - source_representations: a list of unknown representations
        """
        self.persistence_manager = persistence_manager
        self.source_representations = source_representations

    def find_closest_representations(self, metric='euclidean', model='Facenet512') -> list:
        """
            This method is used to find the FaceRepresentation
            whose embeddings are the closest possible to the FaceRepresentation
            setted as input of the class during init operations
                - metric:   the metric used to evaluate the distance between the representations.
                            [cosine, euclidean]
                - return:   a list of the found identies from the input FaceRepresentation list
                - raise:    ValueError if no distances are found
        """
        found_identities = list()

        tic = time.time()
        is_downloaded = self.persistence_manager.download(REPRESENTATIONS_BLOB)
        tac = time.time()

        if is_downloaded:
            print(f'Downloaded representations data in {str(tac - tic)} seconds')
            with open(REPRESENTATIONS_BLOB, 'rb') as f:
                known_representations = pickle.loads(f.read())

            treshold = findThreshold(model_name=model, distance_metric=metric)

            # List that saves the distances scores of the i_th representation
            # against all the ones, already stored in the storage. It must be
            found_distances = list()

            for i, unknown in enumerate(self.source_representations):
                # For every unknown input representation, calculate the distances
                # againt all the known representations
                for j, known in enumerate(known_representations):
                    distance = findEuclideanDistance(known.embedding, unknown.embedding)
                    found_distances.append(distance)
                    print(f'{i} => {j} - {distance}')

                # Find the index of the lowest distance
                if len(found_distances) == 1:
                    min_dist_index = 0
                else:
                    min_dist_index = argmin(found_distances)
                    print(min_dist_index)

                if len(found_distances) > 0 and found_distances[min_dist_index] <= treshold:
                    # Get the index of the minimum distance found during the process and extract the representation
                    entry: FaceRepresentation = known_representations[min_dist_index]
                    found_identities.append(f'{entry.username} - {entry.info}')
                    print(f'Generated identity for {i} - with min distance {found_distances[min_dist_index]}')
                
                # Clear the list at the end of cycle to save 
                # the distances for the next input representation
                found_distances.clear()

        self.__clean_temp_file()

        return found_identities
    
    def verify_identity(self, target_username: str, model='Facenet512', metric='euclidean') -> bool:
        """
            This method is used to verify if the source representation corresponds
            to the target representation identified by the username. It's a verification-like task.
                - source: the source list of representations to be verified
                - target_username: the unique id of the representation which will be evaluated against source                    - return: a boolean value according to the operation status
                - raise: StopIteration if the target_username does not exist
            """
        contains = False

        if self.persistence_manager.download(REPRESENTATIONS_BLOB):
            # Get the target representation                
            with open(REPRESENTATIONS_BLOB, 'rb') as f:
                all_representation: list = pickle.loads(f.read())

            # Get if it exsists the unique representation with the target username
            target: FaceRepresentation = next(rep for rep in all_representation if rep.username == target_username)

            treshold = findThreshold(model, metric)
                
            found_distances: list = []

            for source in self.source_representations:
                found_distances.append(findEuclideanDistance(source.embedding, target.embedding))

            # If the min distance is less than the treshold value then the input 
            # representation contains the target identity
            contains = min(found_distances) <= treshold

        self.__clean_temp_file()

        return contains   
    

    @staticmethod
    def __clean_temp_file():
        """
            Class method used to clean temporary files
        """
        if isfile(USERNAMES_BLOB):
            remove(USERNAMES_BLOB)

        if isfile(REPRESENTATIONS_BLOB):
            remove(REPRESENTATIONS_BLOB)