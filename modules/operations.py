from deepface.DeepFace import represent, extract_faces
from deepface.commons.distance import findThreshold, findEuclideanDistance
from numpy import argmin
from modules.blobs import BlobManager
from os import remove
from os.path import isfile

import pickle
import time

# If this constant is set, the input parameter is skipped. It is primarily used
# on the username and info input parameter in the FaceRepresentation class. That's 
# because if the action of 'find the closest representation' is performed, the
# FaceRepresentationManager just needs the embeddings of the input image to find
# the closest FaceRepresentation object.
SKIP = 'skip'
# A constant that defines the container of the blobs
CONTAINER_NAME = 'dfdb'
# A constant that defines the name of the blob that contains all the usernames
USERNAMES_BLOB = 'usernames.pkl'
# A constant that defines the name of the blob that contains all the representations
REPRESENTATIONS_BLOB = 'representations.pkl'


class FaceRepresentation:

    def __init__(self, username=SKIP, info=SKIP, embedding=SKIP) -> None:
        """
            - username: the identity of the representation
            - info:     additional information
            If no value is specified for username and info, then the instance will
            be considered as an unknown FaceRepresentation. By default, the embedding
            is setted to None, if not generated by generate_representation_single_face method
        """
        self.username = username
        self.info = info
        self.embedding = embedding


class DeepFaceWrapper:

    def __init__(self, img, backend, model) -> None:
        """
            - img:  the img whose representation will be generated. This could be a path
                        to an existing file, or a numpy array
            - backend:  specify which face detector backend to use
            - model:    specify the model used to generate the embedding
        """
        if isinstance(img, str) and not isfile(img):
            raise OSError('The file does not exist')

        self.img = img
        self.backend = backend
        self.model = model

    def generate_embeddings(self):
        """
            This method generates all the embeddings for faces found in the image
            and returns it.
            - Returns: the list of embeddings. The number of elements is the number of found faces
        """
        tic = time.time()

        representations = represent(img_path=self.img, detector_backend=self.backend, model_name=self.model)
        embeddings = list()

        for rep in representations:
            embeddings.append(rep['embedding'])

        tac = time.time()

        print("Spent time generating representation: {}".format(tac - tic))

        return embeddings

    def extract_facial_areas(self):
        """
            This method generates the coordinates of the faces found in the pictures
                - Returns: a list of dictionary with the coordinates (x1, y1) and (x2, y2) for all the faces found
        """
        faces = extract_faces(img_path=self.img, detector_backend=self.backend)
        coordinates = list()

        for face in faces:
            entry = dict()
            facial_area = face['facial_area']

            # Set face points
            entry['x1'] = facial_area['x']
            entry['y1'] = facial_area['y']
            entry['x2'] = facial_area['x'] + facial_area['w']
            entry['y2'] = facial_area['y'] + facial_area['h']

            coordinates.append(entry)

        return coordinates


class FaceRepresentationManager:

    def __init__(self, container_name=CONTAINER_NAME) -> None:
        self.blob_manager = BlobManager(container_name, connection_string=CONNECTION_STRING)  # Get an instance of the blob manager

    @staticmethod
    def __clean_temp_file():
        """
            Class method used to clean temporary files
        """
        if isfile(USERNAMES_BLOB):
            remove(USERNAMES_BLOB)

        if isfile(REPRESENTATIONS_BLOB):
            remove(REPRESENTATIONS_BLOB)

    def upload_representation(self, rep: FaceRepresentation) -> bool:
        """
            This method is used to upload the FaceRepresentation
            to the Blob storage on Azure.
                - rep:      the FaceRepresentation to upload
                - Return:   a boolean value
        """
        if rep.username is SKIP or rep.info is SKIP or rep.embedding is SKIP:
            raise ValueError('Could not perform this action. Username and info are setted as SKIP, or embedding is '
                             'not evaluatd')

        # Register the username if it is not duplicated
        is_username_free = self.__register_username(rep.username)

        if is_username_free:
            # Read the pkl representation file
            is_downloadable = self.blob_manager.download_blob_to_file(REPRESENTATIONS_BLOB)

            # If the data can be downloaded, open the file and extract 
            # the FaceRepresentations using pickle
            if is_downloadable:
                with open(REPRESENTATIONS_BLOB, 'rb') as f:
                    representations: list = pickle.loads(f.read())
            else:
                # Instantiate an empty list if the file is not created
                representations: list = list()

            # Append the new representation    
            representations.append(rep)

            # Update the pickle file
            with open(REPRESENTATIONS_BLOB, 'wb') as f:
                f.write(pickle.dumps(representations))

            self.blob_manager.upload_blob(REPRESENTATIONS_BLOB)

        self.__clean_temp_file()

        return is_username_free

    def remove_representation_by_username(self, username):
        # not implemented yet
        pass

    def verify_identity(self, source_representations: list, target_username: str,
                        model='Facenet512', metric='euclidean') -> bool:
        """
            This method is used to verify if the source representation corresponds
            to the target representation identified by the username. It's a verification-like task.
                - source: the source list of representations to be verified
                - target_username: the unique id of the representation which will be evaluated against source
                - return: a boolean value according to the operation status
                - raise: StopIteration if the target_username does not exist
        """
        contains = False

        if self.blob_manager.download_blob_to_file(REPRESENTATIONS_BLOB):
            # Get the target representation
            with open(REPRESENTATIONS_BLOB, 'rb') as f:
                all_representation: list = pickle.loads(f.read())

            # Get if it exsists the unique representation with the target username
            target: FaceRepresentation = next(rep for rep in all_representation if rep.username == target_username)

            treshold = findThreshold(model, metric)
            
            found_distances: list = []

            for source in source_representations:
                found_distances.append(findEuclideanDistance(source.embedding, target.embedding))

            # If the min distance is less than the treshold value then the input 
            # representation contains the target identity
            contains = min(found_distances) <= treshold

        self.__clean_temp_file()

        return contains

    def find_closest_representations(self, unknown_representations: list,
                                     metric='euclidean', model='Facenet512') -> list:
        """
            This method is used to find the FaceRepresentation
            whose embeddings are the closest possible to the FaceRepresentation
            setted as input of the class, during init operations
                - metric:   the metric used to evaluate the distance between the representations.
                            [cosine, euclidean]
                - return:   a list of the found identies from the input FaceRepresentation list
                - raise:    ValueError if no distances are found
        """
        found_identities = list()

        tic = time.time()
        is_downloaded = self.blob_manager.download_blob_to_file(REPRESENTATIONS_BLOB)
        tac = time.time()

        if is_downloaded:
            print(f'Downloaded representations data in {str(tac - tic)} seconds')
            with open(REPRESENTATIONS_BLOB, 'rb') as f:
                known_representations = pickle.loads(f.read())

            treshold = findThreshold(model_name=model, distance_metric=metric)
            found_distances = list()

            for i, unknown in enumerate(unknown_representations):
                # For every unknown input representation, calculate the distances
                # againt all the known representations
                for j, known in enumerate(known_representations):
                    distance = findEuclideanDistance(known.embedding, unknown.embedding)
                    found_distances.append(distance)
                    print(f'{i} : {j} - {distance}')

                # Find the index of the lowest distance
                if len(found_distances) == 1:
                    min_dist_index = 0
                elif len(found_distances) > 1:
                    min_dist_index = argmin(found_distances)

                if len(found_distances) > 0 and found_distances[min_dist_index] <= treshold :
                    # Get the index of the minimum distance found during the process and extract the representation
                    entry: FaceRepresentation = known_representations[min_dist_index]
                    found_identities.append(f'{entry.username} - {entry.info}')
                    print(f'Generated identity for {i} - with min distance {found_distances[min_dist_index]}')
                    found_distances.clear()

        self.__clean_temp_file()

        return found_identities
    

    def __register_username(self, username) -> bool:
        """
            - username: the username to check
            - Return: This method returns True if the username is
            already registered, False otherwise
        """
        is_downloaded = self.blob_manager.download_blob_to_file(USERNAMES_BLOB)
        usernames_set = set()

        if is_downloaded:
            with open(USERNAMES_BLOB, 'rb') as f:
                usernames_set: set = pickle.loads(f.read())

        flag = username not in usernames_set

        if flag:
            usernames_set.add(username)

            with open(USERNAMES_BLOB, 'wb') as f:
                f.write(pickle.dumps(usernames_set))

            self.blob_manager.upload_blob(USERNAMES_BLOB)

        return flag
